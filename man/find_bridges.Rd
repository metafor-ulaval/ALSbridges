% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/segment_bridge.R
\name{find_bridges}
\alias{find_bridges}
\title{Find the bridges in a point cloud}
\usage{
find_bridges(
  las,
  location = NULL,
  buffer = 75,
  th_planarity = 40,
  th_angle = 8,
  th_hag = 0.9,
  query_stream = NULL,
  force_stream = FALSE,
  ...
)
}
\arguments{
\item{las}{A LAS object from lidR}

\item{location}{numeric. The approximate coordinates of the bridges to look for (in the CRS of the point cloud).
Default is NULL: the method searches from the centroid of the point cloud.}

\item{buffer}{numeric. Bigger than the bridge. This is used to clip the point cloud and reduce the search area,
but it is not used to find the bridge itself. If the buffer is too small and the bridge is partially
missing, the bridge could be missed. If the buffer is too large, the computation time is longer.}

\item{th_planarity}{numeric. A threshold to estimate the planarity of the local geometry. More than
this value is considered planar (see details).}

\item{th_angle}{numeric. A threshold to estimate the horizontality of the local geometry. A bridge is
planar AND horizontal. An angle of 5 degrees is enough in most cases, but with noisy data being more tolerant
may be suitable.}

\item{th_hag}{numeric. A threshold on height above ground. A bridge is a horizontal plane above the ground.
Above the ground is defined by this parameter. Default 90 cm.}

\item{query_stream}{a function capable of querying from a database of streams. It is used for robust
filtering of false positive bridges. It can be omitted. To know how to create your own function, look
at the code of \code{ALSbridges:::jr_internal_stream_query}. Copy-paste the code and adjust to your needs.}

\item{force_stream}{boolean. By default, the streams are queried only if there are more than one bridge
found. If force_stream = TRUE, a stream is always queried to check the bridges.}

\item{...}{Internals for debugging, e.g., display = TRUE.}
}
\value{
NULL if no bridge found. An \code{sf} object with the bounding boxes of the bridges found.
}
\description{
Find bridges in a point cloud and return their bounding box. The function does not scan the entire
point cloud but rather relies on an existing map that is supposed to be approximately correct. Then,
the function searches at this location within a buffer.
}
\details{
About planarity: we use a different definition than the regular definition. \eqn{a_1, a_2, a_3}{a1, a2, a3}
denote the eigenvalues of the covariance matrix of the neighboring points in ascending order. The planarity
is \eqn{(a_2 - a_1) / a_3}{(a2 - a1) / a3} and ranges in  \eqn{[0, 1]}. This definition is the correct definition
of the planarity but, in practice, may lead to weird behaviors in some point cloud sampling patterns. Instead,
we use \eqn{a_3 / a_1}{a3/a1}. This value ranges between \eqn{[0, +infinity]}. This is not the correct definition
of the planarity but appears to work effectively better without being affected by some sampling patterns.
\code{th_planarity} = 15 is very tolerant, 40 is tolerant; 75 will detect only very coplanar points. A
planar object may easily have a planarity threshold above 100, but with noisy data, 40 or even 15 is more likely.
If \code{th_planarity} < 1 then the algorithm uses the true definition of the planarity.
}
\examples{
library(lidR)
library(ALSbridges)

LASfile <- system.file("extdata", "16_2175571f05_dc_000045.laz", package="ALSbridges")
las = readLAS(LASfile)

bridge = find_bridges(las, th_planarity = 50, th_angle = 5, buffer = 130, th_hag = 0.9)
bridge

plot(header(las))
plot(bridge, add = TRUE)

plot(las) |> add_hulls3d(bridge, col = "red")

las = classify_bridges(las, bridge, upper_buffer = 25)
plot(las, color = "Classification")
}
\seealso{
\code{\link[=classify_bridges]{classify_bridges()}}
}
